#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 6.1
#  in conjunction with Tcl version 8.6
#    May 13, 2021 04:27:49 PM CEST  platform: Windows NT
#    May 13, 2021 06:27:19 PM CEST  platform: Windows NT
#    May 14, 2021 06:15:22 PM CEST  platform: Windows NT
#    May 19, 2021 05:14:50 PM CEST  platform: Windows NT
#    May 19, 2021 05:30:26 PM CEST  platform: Windows NT
#    May 19, 2021 05:56:42 PM CEST  platform: Windows NT

from os import name
import sys
import os.path
import figureGen
import pandas as pd
import numpy as np
import shutil
import socket
import select
import pickle
from io import StringIO

import tkinter as tk

import tkinter.ttk as ttk

def set_Tk_var():
    global free_mode_check
    free_mode_check = tk.BooleanVar()
    global selectedButton
    selectedButton = tk.IntVar()

def onValidate(d, i, S):
    if d == '1':
        if S == " ":
            w.Entry_Point.insert(i, 'X')
            w.Entry_Point.configure(validate="key")
            return False
        elif S == ",":
            w.Entry_Point.insert(i, 'T')
            w.Entry_Point.configure(validate="key")
            return False
    return True


def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top
    # --- Start of init edit ---
    global prog_location
    prog_call = sys.argv[0]
    prog_location = os.path.split(prog_call)[0]

    csvfolder = os.path.join(prog_location, "csv")
    try:
        shutil.rmtree(csvfolder)
    except OSError as e:
        print("Error: %s - %s." % (e.filename, e.strerror))
    os.mkdir(csvfolder)

    global target
    target = figureGen.Target([3, 4, 5, 51], totalSize=1.2)

    # Create default image
    update_img(point=None, defaultImg=True)

    global log
    log = pd.DataFrame(columns=['Name', 'Style', 'Point', 'Clock'])

    global users
    users = ['Per Persson','Johan Johansson','Sven Svensson']
    w.TCombobox1.configure(values=users)

    global radios
    radios = {'St': w.radiobuttons[0],
             'J': w.radiobuttons[1],
             'L': w.radiobuttons[2],
             'D': w.radiobuttons[3]}

    # global Label_PointError_location
    # Label_PointError_location = w.Label_PointError.place_info()
    # w.Label_PointError.place_forget()
    w.Label_PointError.grid_remove()

    # global Label_ClockError_location
    # Label_ClockError_location = w.Label_ClockError.place_info()
    # w.Label_ClockError.place_forget()
    w.Label_ClockError.grid_remove()

    w.Entry_Clock.configure(state='disabled')
    w.Entry_Point.configure(state='disabled')

    vcmd = (root.register(onValidate),
        '%d', '%i', '%S')
    w.Entry_Point.configure(validate="key", validatecommand=vcmd)

    for column in ['St', 'J', 'L', 'D']:
        radios[column].configure(state='disabled')


    """
    --- Socket init --- 
    """

    HOST = '192.168.1.4'
    PORT = 12345
    global s
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("Socket created")

    while True:
        try:
            s.bind((HOST, PORT))
            print("Bound succesfully")
            break
        except socket.error:
            print('Bind failed')
    root.after(500, socket_listen)

    # --- End of init edit ---



def delete_item(_, latest=False):
    if  latest:
        selectedButton.get()
        index = (0,)
    else:
        index = w.Listbox1.curselection()
        print(index)

    global log
    try:
        entry = log.iloc[index[0], :]
    except IndexError:
        print("No item selected to delete in listbox")
        return

    if entry['Name'] in [None, '']:
        pass
    else:
        filename = os.path.join(prog_location, "csv", str(entry['Name'])+".csv")
        df = pd.read_csv(filename, squeeze=True, dtype='str')
        row = df[df[entry['Style']] == entry['Point']].last_valid_index()
        df.at[row, entry['Style']] = np.nan
        df.to_csv(filename, index=False)

        buffer = StringIO() # Behaves as a txt file but in memory
        df.to_csv(buffer)
        socket_send(entry['Name'].encode(), "name")
        socket_send(pickle.dumps(buffer), "shooter")


    log.drop([index[0]], inplace=True)
    log.reset_index(inplace=True, drop=True)
    print("")
    print(log.values)

    w.Listbox1.delete(index)

    buffer = StringIO() # Behaves as a txt file but in memory
    log.to_csv(buffer)
    socket_send(pickle.dumps(buffer), "log_df")

    update_radiobuttons()

def add_item(point, clock=None):
    name = w.TCombobox1.get()

    if name == '':
        column = None
        if clock == None:
            string = " " + str(point)
        else:
            string = " {} kl {}".format(str(point), str(clock))
    else:
        filename = os.path.join(prog_location, "csv", str(name)+".csv")
        df = pd.read_csv(filename, squeeze=True, dtype='str')

        column = ['St', 'J', 'L', 'D'][selectedButton.get()-1]
        row = pd.isnull(df[column]).values.nonzero()[0][0]
        print(row)

        df.at[row, column] = point
        df.to_csv(filename, index=False)

        if not df[column].isnull().values.any(): # If column is full
            w.Entry_Point.bind('<Key-Return>', _dummy) # Fixes anoyying bug circumventing disabled entry
            w.Entry_Point.bind('<KP_Enter>', _dummy) # Fixes anoyying bug circumventing disabled entry
            w.Entry_Point.delete(0, 'end') # Clears entry
            update_radiobuttons()
            
        if clock == None:
            string = " {}: [{}] {}".format(name.split()[0], column, str(point))
        else:
            string = " {}: [{}] {} kl {}".format(name.split()[0], column, str(point), str(clock))

        buffer = StringIO() # Behaves as a txt file but in memory
        df.to_csv(buffer)
        socket_send(name.encode(), "name")
        socket_send(pickle.dumps(buffer), "shooter")


    global log
    log.loc[-1] = [name, column, point, clock]
    log.index += 1
    log = log.sort_index()
    print("")
    print(log.values)

    w.Listbox1.insert(0, string)
    w.Listbox1.see(0)

    buffer = StringIO() # Behaves as a txt file but in memory
    log.to_csv(buffer)
    socket_send(pickle.dumps(buffer), "log_df")
    socket_send(pickle.dumps((point, clock)), "new_hit")

def format_csv(name):
    filename = os.path.join(prog_location, "csv", str(name)+".csv")
    df = pd.read_csv(filename, squeeze=True)
    df = df.fillna('-')
    for key in ['St', 'J', 'L', 'D']:
        df[key] = df[key].astype(str)
        df[key] = df[key].str.split('.')
        df[key] = df[key].str[0]
    df.to_csv(filename, index=False)

def _from_combobox(_):
    w.Label_name.focus()
    update_radiobuttons()

def update_radiobuttons():
    name = w.TCombobox1.get()
    columns=['St', 'J', 'L', 'D']

    for column in columns:
        radios[column].configure(state='disabled')
    selectedButton.set(0)

    if name != '':
        filename = os.path.join(prog_location, "csv", str(name)+".csv")
        
        if not os.path.exists(filename):
            with open(filename, 'w'): pass
            df = pd.DataFrame(np.nan, index=[0, 1, 2, 3], columns=columns)
            df.to_csv(filename, index=False)
            for column in columns:
                radios[column].configure(state='normal')
        else:
            from_csv = pd.read_csv(filename, squeeze=True)

            for column in columns:
                if from_csv[column].isnull().values.any():
                    radios[column].configure(state='normal')
            
            if selectedButton.get() == 0:
                w.Entry_Point.configure(state='disabled')

def allow_entry():
    w.Entry_Point.configure(state='normal')
    w.Entry_Point.bind('<Key-Return>', point_entry)
    w.Entry_Point.bind('<KP_Enter>', point_entry)
    w.Entry_Point.focus()

def _dummy(_):
    pass

def clock_entry(_):
    # w.Label_ClockError.place_forget()
    w.Label_ClockError.grid_remove()
    root.update()
    point = w.Entry_Point.get()
    clock = w.Entry_Clock.get()

    if point_entry(_, update=False) and clock in ['12', '11', '10', '9', '8', '7', '6', '5', '4', '3', '2','1']:
        add_item(point, clock)
        update_img(point, int(clock))
        w.Entry_Point.delete(0, 'end')
        w.Entry_Clock.delete(0, 'end')
        w.Entry_Point.focus()
        w.Entry_Clock.configure(state='disabled')
    else:
        w.Entry_Clock.delete(0, 'end')
        root.after(100) # Cause a delay for error label to flash for feedback
        # w.Label_ClockError.place(x=Label_ClockError_location['x'], y=Label_ClockError_location['y'])
        w.Label_ClockError.grid()

def point_entry(_, update=True):
    # w.Label_PointError.place_forget()
    w.Label_PointError.grid_remove()
    root.update()
    point = w.Entry_Point.get()

    # Convert elements to str to compare to "point"
    str_pointRange = []
    for item in target.pointRange: 
        str_pointRange.append(str(item))

    if point in str_pointRange[1:]: # All but center
        if update:
            update_img(point)
        w.Entry_Clock.configure(state='normal')
        w.Entry_Clock.focus()
    
    elif point == str_pointRange[0]: # Center/bullseye
        add_item(point)
        update_img(point)
        w.Entry_Point.delete(0, 'end')

    elif point in ["Miss", "x", "X"]:
        add_item(point)
        update_img(point)
        w.Entry_Point.delete(0, 'end')

    elif point in ["T", "t", "o", "O", 0, "0"]: # Hit on figure but ouside target area
        if update:
            update_img(point)
        w.Entry_Clock.configure(state='normal')
        w.Entry_Clock.focus()        
        
    else:
        w.Entry_Point.delete(0, 'end')
        root.after(100) # Cause a delay for error label to flash for feedback
        # w.Label_PointError.place(
        #     x=Label_PointError_location['x'],
        #     y=Label_PointError_location['y']
        # )
        w.Label_PointError.grid()
        w.Entry_Clock.configure(state='disabled')
        return False
    return True

def update_img(point, clock=None, defaultImg=False):
    if defaultImg:
        target.default()
    else:
        try:
            target.targetHit(int(point), clock)
        except ValueError:
            target.targetHit(point, clock)
    target.saveFigure(dpi=80)
    photo_location = os.path.join(prog_location,"./image.png")
    global _img0
    _img0 = tk.PhotoImage(file=photo_location)
    w.Image.configure(image=_img0)

def open_print_window():
    print('sender_support.open_print_window', flush=True)

def free_mode():
    print('sender_support.free_mode', flush=True)
    if free_mode_check.get() is True:
        w.TCombobox1.set('')
        w.TCombobox1.configure(state='disabled')
        allow_entry()
    else:
        w.TCombobox1.configure(state='readonly')
        w.Entry_Point.configure(state='disabled')
        w.Entry_Point.bind('<Key-Return>', _dummy) # Fixes anoyying bug circumventing disabled entry
        w.Entry_Point.bind('<KP_Enter>', _dummy) # Fixes anoyying bug circumventing disabled entry
        # w.Entry_Point.delete(0, 'end') # Removes
    update_radiobuttons()

"""
    Begining of socket functions
"""
def socket_listen():
    s.listen(1)
    s.setblocking(False)
    print("Socket awaitning connection")
    global conn, addr
    i=0
    open_popup()
    while True:
        try:
            (conn, addr) = s.accept()
            break
        except BlockingIOError:
            i += 1
            print('/-\|'[i%4]+'\r',end='',flush=True)
    print("Connected")
    close_popup()
    root.after(2000, socket_recive)

def socket_send(data, data_info):
    data_info = data_info.lower()
    if len(str(data_info)) > 8:
        raise ValueError("Data_info has to be max 8 characters, was: " + str(len(data_info)))
    data_info = f'{data_info: <8}'

    size = len(data) + len(data_info) + 2   # 2 is for "packet_len"
    FULL_BYTE = int(0xFF)
    packet_len = bytes([size//FULL_BYTE, size % FULL_BYTE]) # Returns two bytes to store the packet size excluding bytes for TCP protocoll
    prefix = packet_len + data_info.encode()
    print(len(prefix + data))
    try:
        conn.sendall(prefix + data)
    except (ConnectionResetError, ConnectionAbortedError, BrokenPipeError) as e:
        print(e)
        socket_listen()
        socket_send(data, data_info)

def socket_recive():
    FULL_BYTE = int(0xFF)
    msg = b''
    msg_list = []
    length = 0
    has_read = False
    while True:
        r,w,e = select.select([conn], [], [], 0.2)
        if r:
            try:
                msg += conn.recv(2048)
                has_read = True
            except (ConnectionResetError, ConnectionAbortedError, BrokenPipeError) as e:
                print(e)
                socket_listen()
                
        if len(msg) >= 2:

            if length == 0:
                length = int(msg[0])*FULL_BYTE + int(msg[1]) # Convert first 2 bytes to decimal
                print(length)

            if len(msg) >= length and length:
                data_info = msg[2:10]
                data = msg[10:length]
                msg_list.append((data, data_info.decode().strip()))
                msg = msg[length:]
                length = 0

        if not len(msg):
            root.after(500, socket_recive)
            if has_read:
                act_on_msg(msg_list)
            # return msg_list
            return

"""
    End of socket functions
"""

def act_on_msg(msg_list):
    while msg_list:
        encoded_data, data_info = msg_list.pop(0)
        
        if data_info == "ping":
            pass

        elif data_info == "name":
            shooter_name = encoded_data.decode()
            users.insert(0, shooter_name)
            w.TCombobox1.configure(values=users)
            w.TCombobox1.current([0])
            free_mode_check.set(False)
            free_mode()
            _from_combobox("dummy_param")

        elif data_info == "leader":
            global leader_name
            leader_name = encoded_data.decode()
            print("Current leader is " + leader_name)

        elif data_info == "date":
            print("Current date is " + encoded_data.decode())

        else:
            print("Unrecognizeable info: " + data_info)
            print("Was carrying this data: " + str(encoded_data))


class Popup(tk.Toplevel):
    """modal window requires a master"""
    def __init__(self, master, **kwargs):
        tk.Toplevel.__init__(self, master, **kwargs)
        # self.overrideredirect(True)
        self.geometry('320x100+240+190') # set the position and size of the popup

        lbl = tk.Label(self, text="Försöker koppla til skjutardatorn ... ", font=("Segoe UI", 11, "bold"))
        lbl.place(relx=.5, rely=.5, anchor='c')
        self.title("Connecting...")

        # The following commands keep the popup on top.
        # Remove these if you want a program with 2 responding windows.
        # These commands must be at the end of __init__
        self.transient(master) # set to be on top of the main window
        self.grab_set() # hijack all commands from the master (clicks on the main window are ignored)

def open_popup():
    root.popup = Popup(root)
    root.update()

def close_popup():
    root.popup.destroy()



def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None

if __name__ == '__main__':
    import sender
    sender.vp_start_gui()





