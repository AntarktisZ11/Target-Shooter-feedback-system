#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 6.1
#  in conjunction with Tcl version 8.6
#    May 13, 2021 04:27:49 PM CEST  platform: Windows NT
#    May 13, 2021 06:27:19 PM CEST  platform: Windows NT
#    May 14, 2021 06:15:22 PM CEST  platform: Windows NT
#    May 19, 2021 05:14:50 PM CEST  platform: Windows NT
#    May 19, 2021 05:30:26 PM CEST  platform: Windows NT
#    May 19, 2021 05:56:42 PM CEST  platform: Windows NT

import sys
import os

import figureGen  # Local file
import sender_extra_windows as windows  # Local file

# import sender
# from sender import Toplevel1
from socket_stuff import SenderSocket  # ! Have to try and implement to reduce single file length

import pandas as pd
import numpy as np

import pickle
from io import StringIO

import tkinter as tk


def set_Tk_var():
    global free_mode_check
    free_mode_check = tk.BooleanVar()
    global selectedButton
    selectedButton = tk.IntVar()


def onValidate(d, i, S):
    if d == "1":
        if S == " ":
            w.Entry_Point.insert(i, "X")
            w.Entry_Point.configure(validate="key")
            return False
        elif S == ",":
            w.Entry_Point.insert(i, "T")
            w.Entry_Point.configure(validate="key")
            return False
    return True


def init(top: tk.Tk, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top

    # --- Start of init edit ---
    global PROG_LOCATION
    prog_call = sys.argv[0]
    PROG_LOCATION = os.path.split(prog_call)[0]

    global target
    target = figureGen.Target([3, 4, 5, 51], totalSize=1, dpi=120)

    # Create default image
    update_img_default()

    global log
    log = pd.DataFrame(columns=["Name", "Style", "Point", "Clock"])

    global users
    users = []
    csv_folder = os.listdir(os.path.join(PROG_LOCATION, "csv"))
    for file in csv_folder:
        name = os.path.splitext(file)[0]
        users.append(name)

    w.TCombobox1.configure(values=users)

    global radios
    radios = {
        "St": w.radiobuttons[0],
        "J": w.radiobuttons[1],
        "L": w.radiobuttons[2],
        "D": w.radiobuttons[3],
    }

    w.Label_PointError.grid_remove()
    w.Label_ClockError.grid_remove()

    w.Entry_Clock.configure(state="disabled")
    w.Entry_Point.configure(state="disabled")

    vcmd = (root.register(onValidate), "%d", "%i", "%S")
    w.Entry_Point.configure(validate="key", validatecommand=vcmd)

    for column in ["St", "J", "L", "D"]:
        radios[column].configure(state="disabled")

    windows.init_globals(top, gui, PROG_LOCATION, users)
    # windows.set_leader_name("L-O Nilsson")

    """
    --- Socket init ---
    """

    global socket
    socket = SenderSocket.SenderSocket(root, act_on_msg)  # * Init socket

    windows.open_distance_popup()

    # --- End of init edit ---


def delete_user(user: str = None):
    if user is None:
        user = w.TCombobox1.get()

    try:
        users.remove(user)
        remove_files(user)  # ! Clear csv and pdf
    except ValueError as e:
        print(e)
        print(f"User: {user} not found in list for deletion")
    if user == w.TCombobox1.get():
        w.TCombobox1.set("")
        w.Combobox_tooltip.disable()
        w.Combobox_tooltip.hide()
        update_radiobuttons()

    w.TCombobox1.configure(values=users)


def remove_files(user):
    csv_path = os.path.join(PROG_LOCATION, "csv", f"{user}.csv")
    pdf_path = os.path.join(PROG_LOCATION, "PDFs", f"{user}.pdf")

    for path in [csv_path, pdf_path]:
        if os.path.exists(path):
            os.remove(path)
        else:
            print("The file does not exist")


def delete_item(_, latest: bool = False):
    if latest:
        # selectedButton.get()
        index = (0,)
    else:
        index = w.Listbox1.curselection()
        print(index)

    global log
    try:
        entry = log.iloc[index[0], :]
    except IndexError:
        print("No item selected to delete in listbox")
        return

    if entry["Name"] in [None, ""]:
        pass
    else:
        filename = os.path.join(PROG_LOCATION, "csv", str(entry["Name"]) + ".csv")
        df = pd.read_csv(filename, squeeze=True, dtype="str")
        row = df[df[entry["Style"]] == entry["Point"]].last_valid_index()
        df.at[row, entry["Style"]] = np.nan
        df.to_csv(filename, index=False)

        buffer = StringIO()  # Behaves as a txt file but in memory
        df.to_csv(buffer)
        socket.send(entry["Name"].encode(), "name")
        socket.send(pickle.dumps(buffer), "shooter")

    log.drop([index[0]], inplace=True)
    log.reset_index(inplace=True, drop=True)
    print("")
    print(log.values)

    w.Listbox1.delete(index)

    buffer = StringIO()  # Behaves as a txt file but in memory
    log.to_csv(buffer)
    socket.send(pickle.dumps(buffer), "log_df")

    update_radiobuttons()


def add_item(point, clock=None):
    """If no name is selected in combobox; send
     - new hit
     - updated log.

    If name was selected; update csv and DataFrame send following to receiver
     - shooter name
     - shooter DataFrame
     - new hit
     - updated log"""

    name = w.TCombobox1.get()

    if name == "":
        column = None
        if clock is None:
            string = " " + str(point)
        else:
            string = " {} kl {}".format(str(point), str(clock))
    else:
        filename = os.path.join(PROG_LOCATION, "csv", str(name) + ".csv")
        df = pd.read_csv(filename, squeeze=True, dtype="str")

        column = ["St", "J", "L", "D"][selectedButton.get() - 1]
        row = pd.isnull(df[column]).values.nonzero()[0][0]
        print(row)

        df.at[row, column] = point
        df.to_csv(filename, index=False)

        if not df[column].isnull().values.any():  # If column is full
            w.Entry_Point.unbind("<Key-Return>")  # Fixes anoyying bug circumventing disabled entry
            w.Entry_Point.unbind("<KP_Enter>")  # Fixes anoyying bug circumventing disabled entry

            w.Entry_Point.delete(0, "end")  # Clears entry
            w.Entry_Clock.delete(0, "end")  # Clears entry
            update_radiobuttons()

        if clock is None:
            string = " {}: [{}] {}".format(name.split()[0], column, str(point))
        else:
            string = " {}: [{}] {} kl {}".format(name.split()[0], column, str(point), str(clock))

        buffer = StringIO()  # Behaves as a txt file but in memory
        df.to_csv(buffer)
        socket.send(name.encode(), "name")
        socket.send(pickle.dumps(buffer), "shooter")

    global log
    log.loc[-1] = [name, column, point, clock]
    log.index += 1
    log = log.sort_index()
    print("")
    print(log.values)

    w.Listbox1.insert(0, string)
    w.Listbox1.see(0)

    buffer = StringIO()  # Behaves as a txt file but in memory
    log.to_csv(buffer)
    socket.send(pickle.dumps(buffer), "log_df")
    socket.send(pickle.dumps((point, clock)), "new_hit")


def _from_combobox(_):
    w.Label_name.focus()

    name = w.TCombobox1.get()
    if name != "":
        w.Combobox_tooltip.update(name)
        w.Combobox_tooltip.enable()

    update_radiobuttons()


def update_radiobuttons():
    name = w.TCombobox1.get()
    columns = ["St", "J", "L", "D"]

    for column in columns:
        radios[column].configure(state="disabled")
    selectedButton.set(0)

    if name != "":
        filename = os.path.join(PROG_LOCATION, "csv", str(name) + ".csv")

        if not os.path.exists(filename):
            with open(filename, "w"):  # Make file
                pass
            df = pd.DataFrame(np.nan, index=[0, 1, 2, 3], columns=columns)
            df.to_csv(filename, index=False)
            for column in columns:
                radios[column].configure(state="normal")
        else:
            from_csv = pd.read_csv(filename, squeeze=True)

            for column in columns:
                if from_csv[column].isnull().values.any():
                    radios[column].configure(state="normal")

            if selectedButton.get() == 0:
                w.Entry_Point.configure(state="disabled")
                w.Entry_Clock.configure(state="disabled")


def allow_entry():
    w.Entry_Point.configure(state="normal")
    w.Entry_Point.bind("<Key-Return>", point_entry)
    w.Entry_Point.bind("<KP_Enter>", point_entry)
    w.Entry_Point.focus()


def clock_entry(_):
    w.Label_ClockError.grid_remove()
    root.update_idletasks()
    point = w.Entry_Point.get()
    clock = w.Entry_Clock.get()

    if point_entry(_, update=False) and clock in ["12", "11", "10", "9", "8", "7", "6", "5", "4", "3", "2", "1"]:
        add_item(point, clock)
        update_img(point, int(clock))
        w.Entry_Point.delete(0, "end")
        w.Entry_Clock.delete(0, "end")
        w.Entry_Point.focus()
        w.Entry_Clock.configure(state="disabled")
    else:
        w.Entry_Clock.delete(0, "end")
        root.after(100)  # Cause a delay for error label to flash for feedback
        w.Label_ClockError.grid()


def point_entry(_, update: bool = True):
    """Returns True if entry was an accepted value.

    @param update: If True; updates image"""
    w.Label_PointError.grid_remove()
    root.update_idletasks()
    point = w.Entry_Point.get()

    # Convert elements to str to compare to "point"
    str_pointRange = [str(i) for i in target.pointRange]

    if point in str_pointRange[1:]:  # All but center
        if update:
            update_img(point)
        w.Entry_Clock.configure(state="normal")
        w.Entry_Clock.focus()

    elif point == str_pointRange[0]:  # Center/bullseye
        add_item(point)
        update_img(point)
        w.Entry_Point.delete(0, "end")

    elif point in ["Miss", "x", "X"]:
        add_item(point)
        update_img(point)
        w.Entry_Point.delete(0, "end")

    elif point in ["T", "t", "o", "O", 0, "0"]:  # Hit on figure but ouside target area
        if update:
            update_img(point)
        w.Entry_Clock.configure(state="normal")
        w.Entry_Clock.focus()

    else:
        w.Entry_Point.delete(0, "end")
        root.after(100)  # Cause a delay for error label to flash for feedback
        w.Label_PointError.grid()
        w.Entry_Clock.configure(state="disabled")
        return False
    return True


def update_img(point, clock=None):
    if clock is None:
        photo_location = os.path.join(PROG_LOCATION, "images", f"./{point}.png")
    else:
        photo_location = os.path.join(PROG_LOCATION, "images", f"./{point}_{clock}.png")

    if not os.path.exists(photo_location):
        print("Creating new photo")
        try:
            target.targetHit(int(point), clock)
        except ValueError:
            target.targetHit(point, clock)

    global _img0
    _img0 = tk.PhotoImage(file=photo_location)

    w.Image.configure(image=_img0)


def update_img_default():
    photo_location = os.path.join(PROG_LOCATION, "images", "./default.png")
    if not os.path.exists(photo_location):
        target.default()  # ! After this 'photo_location' will exist

    global _img0
    _img0 = tk.PhotoImage(file=photo_location)

    w.Image.configure(image=_img0)


def free_mode():
    print("sender_support.free_mode", flush=True)
    if free_mode_check.get() is True:
        w.TCombobox1.set("")
        w.TCombobox1.configure(state="disabled")
        w.Combobox_tooltip.disable()
        allow_entry()
    else:
        w.TCombobox1.configure(state="readonly")
        w.Entry_Point.configure(state="disabled")
        w.Entry_Clock.configure(state="disabled")
        w.Entry_Point.unbind("<Key-Return>")  # Fixes anoyying bug circumventing disabled entry
        w.Entry_Point.unbind("<KP_Enter>")  # Fixes anoyying bug circumventing disabled entry
    update_radiobuttons()


def act_on_msg():
    while socket.msg_list:
        encoded_data, data_info = socket.msg_list.pop(0)

        if data_info == "ping":  # ! Ping reaction not implemented
            pass
        # global ping_timer
        # if ping_timer is not None:
        #     print(f'Canceling {ping_timer}')
        #     root.after_cancel(ping_timer)
        # ping_timer = root.after(15000, socket.listen)
        # print(f'Scheduling {ping_timer}')

        elif data_info == "shooter":
            shooter_name = encoded_data.decode()
            user_name = shooter_name
            i = 1
            while user_name in users:
                user_name = f"{shooter_name} ({i})"
                i += 1
            users.insert(0, user_name)

            w.TCombobox1.configure(values=users)
            w.TCombobox1.current([0])

            free_mode_check.set(False)
            free_mode()
            _from_combobox("dummy_param")

        elif data_info == "leader":
            # global leader_name
            leader_name = encoded_data.decode()
            windows.set_leader_name(leader_name)
            print("Current leader is " + leader_name)

        elif data_info == "date":
            print("Current date is " + encoded_data.decode())

        elif data_info == "time":
            print("Current time is " + encoded_data.decode())

        else:
            print("Unrecognizeable info: " + data_info)
            print("Was carrying this data: " + str(encoded_data))


def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None


if __name__ == "__main__":
    import sender

    sender.vp_start_gui()
